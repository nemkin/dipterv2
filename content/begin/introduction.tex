\chapter{Introduction}

In recent years, there has been an increasing focus on quantum informatics. Influential global companies such as IBM, Google, Microsoft, and Amazon have invested significant amounts into studying and developing hardware and software for this sector, while the European Union and Hungary have launched several programs to accelerate quantum research.

Current technology is yet to produce a significant number of qubits (quantum bits) in a quantum processor, but many believe the amount will increase over the years. The first practical quantum algorithms to be run on these processors are likely to be the ones that use qubits sparingly. Quantum walking, the generalized version of classical random walking, is exactly this kind of algorithm. The number of qubits required to run a quantum walk on a graph is logarithmic in the number of vertices, making it a promising technique for the near future. Furthermore, Grover's search algorithm (a basis for many quantum algorithms) can be viewed as a special case of quantum walks, which illustrates the potential power of this method.

In my dissertation, I present the mathematical framework for quantum walks, detailing the points critical for implementation, which are given less emphasis in the literature. I describe the architecture and capabilities of the simulator program I have written and the conclusions of the simulations I have run.

I developed the software using Python 3, based on the Strategy design pattern. It supports graphs commonly found in the literature while also providing a method for combining them, facilitating experimentation on several kinds of regular graphs. This composition is also the foundation of the quantum walk. It can simulate classical and quantum walks on the same graphs and produce a report file detailing the results. In the quantum case, the characteristics of the walk are also dependent on the type of coin used to generate the probabilities, which can be defined in several ways. The program includes the Hadamard, Grover, and Fourier coins and can easily be extended with others.

Running several simulations, I compared the behavior of classical and quantum walks and demonstrated the quantum characteristics expected from the theoretical literature, the ballistic nature of the Hadamard walk, and the cyclic property of quantum walks.

Classical random walks are well-known tools for describing different stochastic processes. Many real-life scientific approaches rely on these methods, including stock price movement prediction, natural language processing, Brownian motion description; and evolution, population and disease outbreak models. Other algorithms utilize random walks to gain speed or combat the search space's scale, most notably Google's Page Rank algorithm and various recommender systems.~\cite{XiaReview}.

In recent years quantum computing has been gaining traction amongst researchers and computer scientists. While there exists a wide variety of quantum algorithms to be explored, I specifically targeted quantum walks due to their reasonable hardware requirements and promising features. Quantum walks provide a quadratic speedup compared to their classical counterparts and display behaviour, such as the ballistic nature and the cyclic property that their classical equivalent does not, while only requiring logarithmic space, which due to the various limitations of physical qubit realization is particularly valuable.~\cite{Portugal}

Since currently, the publicly available quantum computers can operate with only around 5-10 qubits, I created a simulator software that runs on a regular computer to experiment with the algorithm. I am hopeful that the time for feasibly switching to quantum hardware is just around the corner.

During my research, I have observed a significant lack of software engineering perspective on this subject. Most research papers are written by physicists who are well acquainted with the details of quantum mechanics with a heavy focus on physics-related formulas and functional descriptions. It has been a strenuous process to gather the motivation and justification of certain implementation choices that seem to be the standard for someone in the inner circle but strange for me, just getting started with the topic.

This report aims to provide a comprehensible introduction to quantum walking from the software engineer's perspective, spending extra effort on implementation-specific details and mathematical proofs missing from the available literature. In contrast with the functional descriptions, I describe the algorithms using linear algebra, allowing for a more natural way to implement the simulation.

The rest of this report is structured in the following way: In Chapters 2 and 3, I briefly introduce classical random walks and quantum computing, using only the necessary formulas and focusing on the details employed later in the report. In Chapter 4, I introduce quantum walking in a bottom-up approach, starting from the simplest form and then generalizing it. Contrary to many authors, I use linear algebra exclusively to describe each step since implementation on a universal quantum computer requires the definition to come in the form of unitary transformations.

Section 4.3 discusses two of the generalization techniques found in~\cite{Portugal}. I present my improvement to one of these methods, which I have proven to have the equivalent result but remove an exponential memory requirement from the implementation. The other method in~\cite{Portugal} uses a constraint about the evolution operator, for which I have not found proof in the literature. Here, I present my more generalized version of this constraint and the proof I have given.

In Chapter 5, I describe the architecture and implementation details of my simulator software, then in Chapter 6, I present the results obtained from my simulation runs.