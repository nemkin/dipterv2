\chapter{Introduction}

Richard Feynman originally suggested the idea of a quantum computer in a 1982 article\cite{feynman_simulating_1982}, demonstrating that current computers experience an exponential slowdown when simulating quantum physical systems. In this paper, he proposes using a different type of computer: one that runs according to the laws of quantum physics, to simulate quantum physical systems without a slowdown.\cite{Hirvensalo}

\section{Computational models and the P versus NP problem}

The mathematical computational model of classical computers is the Turing machine. The laws governing quantum computers are so fundamentally different from their classical relatives that they required defining a new model type. Following the work of many computer scientists (Benioff\cite{benioff_models_1998}, Deutsch\cite{deutsch_quantum_1985}, and Bernstein and Vazirani\cite{bernstein_quantum_1993}), the computational model for quantum computers was born in the late 1980s: the Quantum Turing machine.

In the past century researchers have been working on solving all kinds of classical algorithmic problems with critical real-life applications. They have defined various time complexity classes depending on how fast the current solutions are. Usually, the class P is considered fast enough.

For some problems, despite tremendous effort, researchers have yet to come up with a fast solver, however, they have found fast verifier algorithms. This means, that when a potential solution is suggested for a given task, they can quickly check its correctness. A problem like this is part of the complexity class NP.

To turn a fast verifier algorithm into a brute-force solver, we could search through all of the possible solutions - the domain of the problem - and verify all of them until we find one that passes. This runs in $O(N)$ linear time relative to the size of the problem's domain. The question is, can we do something faster? This is one of the famous unsolved Millennium Prize Problems set by the Clay Mathematics Institute a hundred years ago, the P versus NP problem.

In the quantum world, a better method exists for searching a problem's domain, which can do it in $O(\sqrt{N})$ time relative to the size of the domain. This algorithm is called Grover's search. It has also been proven by Bennett, Bernstein, Brassard, and Vazirani, that this is asymptotically tight\cite{bennett_strengths_1997}.

\section{Application of quantum algorithms in bioinformatics}

A fascinating area for algorithmic research is bioinformatics, with many real-life applications. I am particularly interested in computer-aided drug design, which involves finding molecules of a particular shape that fit into molecular holes of a particular shape inside the human body. From this context, computational problems such as protein folding\cite{crescenzi_complexity_1998} and molecular docking\cite{a_molecular_2018} arise, and among many other bioinformatical problems, turn out to be NP-hard ones. This means that we have yet to devise efficient solutions to them in the classical world.

In the quantum world, Grover's search algorithm could give us a quadratic speedup over its classical brute-force counterpart. Furthermore, Grover's algorithm is an unstructured database search, meaning it does not rely on any information about the structure of the problem's domain.

For example, in the case of protein folding, the structure of the domain could be a simple rule for transforming one fold to another. We could portray this as a graph: the vertices representing all possible folds and the edges representing which folds transform into which others, based on our devised rule.

To boost Grover's speed even further, we could inject this structural information about the domain into it using the quantum equivalent of random graph walks, quantum walks.

\section{Contents of this dissertation}

\todo[inline]{Ezt átírni a végegesre.}

In order to reduce the memory requirements for any quantum computation simulation, I have to be able to reduce storing large operation matrices in memory whenever I can. This requires a completely different architecture.

\subsection{TDK 2021/Dipterv}

The rest of this thesis is structured in the following way: In Chapter 2, I introduce Quantum computing, specifically Quantum Random Walks, in a bottom-up approach, starting from the simplest form and then generalizing it. Contrary to many authors, I use linear algebra exclusively to describe each step since implementation on a universal quantum computer requires the definition to come in the form of unitary transformations.

Section 2.2.5 discusses two of the generalization techniques found in~\cite{Portugal}. I present my improvement to one of these methods, which I have proven to have the equivalent result but remove an exponential memory requirement from the implementation. The other method in~\cite{Portugal} uses a constraint about the evolution operator, for which I have not found proof in the literature. Here, I present my more generalized version of this constraint and the proof I have given.

In Chapter 3, I introduce three bioinformatics problems: DNA sequencing, Protein folding and Molecular docking. I explain the computational models that emerge from these practical problems and the well-known computational problems they reduce to.

In Chapter 4, I describe my simulator software's architecture and implementation details and present the results obtained from my simulation runs.

\subsection{TDK 2022}

The remaining chapters are structured as follows: In Chapter 2 I introduce Grover's search algorithm framework and solve a generalized version of the Sudoku puzzle with it. I iterate over the necessary components from this solution, the particular operators needed for the oracle and the amplitude amplification technique's implementation. In Chapter 3 I lay down the mathematical foundations for a quantum simulator framework's implementation, particularly the solution to applying a quantum operator to a subset of the registers in the system, then I introduce the quantum operators and their implementations in my system. Finally, I describe the architectural design patterns used in the system. In Chapter 4 I summarize the results of this paper and lay down my plans for the future.