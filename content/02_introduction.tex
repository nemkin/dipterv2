\chapter{Introduction}

Richard Feynman originally suggested the idea of a quantum computer in a 1982 article\cite{feynman_simulating_1982}, demonstrating that current computers experience an exponential slowdown when simulating quantum physical systems. In this paper, he proposes using a different type of computer: one that runs according to the laws of quantum physics, to simulate quantum physical systems without a slowdown.\cite{Hirvensalo}

\section{Computational models and the P versus NP problem}

The mathematical computational model of classical computers is the Turing machine. The laws governing quantum computers are so fundamentally different from their classical relatives that they required defining a new model type. Following the work of many computer scientists (Benioff\cite{benioff_models_1998}, Deutsch\cite{deutsch_quantum_1985}, and Bernstein and Vazirani\cite{bernstein_quantum_1993}), the computational model for quantum computers was born in the late 1980s: the Quantum Turing machine.

In the classical world, on the Turing machine, researchers have been working on solving all kinds of algorithmic problems with critical real-life applications. If a fast enough solver is found, the problem is categorized as part of the complexity class P.

For some problems, despite tremendous effort, nobody has been able to come up with a fast solver yet, but at least they have found fast verifier algorithms: when a potential solution is suggested for a given task, they can quickly verify its correctness. A problem like this is part of the complexity class NP.

To turn a fast verifier algorithm into a brute-force solver, we could search through all of the possible solutions - the domain of the problem - and verify all of them until we find one that passes. This runs in $O(N)$ linear time relative to the size of the problem's domain. The question is, can we do something faster? This is one of the famous Millennium Prize Problems set by the Clay Mathematics Institute a hundred years ago, the P versus NP problem. This problem has eluded computer scientists for a century.

In the quantum world, a better method exists for searching a problem's domain, which can do it in $O(\sqrt{N})$ time relative to the size of the domain. This algorithm is called Grover's search. It has also been proven by Bennett, Bernstein, Brassard, and Vazirani, that this is asymptotically tight\cite{bennett_strengths_1997}.

\section{Application of quantum algorithms in bioinformatics}

An interesting area for algorithmic research is bioinformatics with many real-life applications. I am particularly interested in computer-aided drug design, where problems such as protein folding\cite{crescenzi_complexity_1998} and molecular docking\cite{a_molecular_2018} turn out to be NP-hard ones, which means that despite decades of effort, we have yet to come up with efficient solutions to them using classical computers.


\section{Contents of this dissertation}

In order to reduce the memory requirements for any quantum computation simulation, I have to be able to reduce storing large operation matrices in memory whenever I can. This requires a completely different architecture.

\subsection{TDK 2021/Dipterv}

The rest of this thesis is structured in the following way: In Chapter 2, I introduce Quantum computing, specifically Quantum Random Walks, in a bottom-up approach, starting from the simplest form and then generalizing it. Contrary to many authors, I use linear algebra exclusively to describe each step since implementation on a universal quantum computer requires the definition to come in the form of unitary transformations.

Section 2.2.5 discusses two of the generalization techniques found in~\cite{Portugal}. I present my improvement to one of these methods, which I have proven to have the equivalent result but remove an exponential memory requirement from the implementation. The other method in~\cite{Portugal} uses a constraint about the evolution operator, for which I have not found proof in the literature. Here, I present my more generalized version of this constraint and the proof I have given.

In Chapter 3, I introduce three bioinformatics problems: DNA sequencing, Protein folding and Molecular docking. I explain the computational models that emerge from these practical problems and the well-known computational problems they reduce to.

In Chapter 4, I describe my simulator software's architecture and implementation details and present the results obtained from my simulation runs.

\subsection{TDK 2022}

The remaining chapters are structured as follows: In Chapter 2 I introduce Grover's search algorithm framework and solve a generalized version of the Sudoku puzzle with it. I iterate over the necessary components from this solution, the particular operators needed for the oracle and the amplitude amplification technique's implementation. In Chapter 3 I lay down the mathematical foundations for a quantum simulator framework's implementation, particularly the solution to applying a quantum operator to a subset of the registers in the system, then I introduce the quantum operators and their implementations in my system. Finally, I describe the architectural design patterns used in the system. In Chapter 4 I summarize the results of this paper and lay down my plans for the future.