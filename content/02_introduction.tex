\chapter{Introduction}

In recent years, there has been an increasing focus on quantum informatics. Influential global companies such as IBM, Google, Microsoft, and Amazon have invested significant amounts into studying and developing hardware and software for this sector, while the European Union and Hungary have launched several programs to accelerate quantum research.

Current technology is yet to produce a significant number of qubits (quantum bits) in a quantum processor, but many believe the amount will increase over the years. The first practical quantum algorithms to be run on these processors are likely to be the ones that use qubits sparingly. Quantum walking, the generalized version of classical random walking, is exactly this kind of algorithm. The number of qubits required to run a quantum walk on a graph is logarithmic in the number of vertices, making it a promising technique for the near future. Furthermore, by extending the quantum walk algorithm with an oracle, it can be used to perform database search-based algorithms, which could be used for solving many of the computationally hard bioinformatical problems.

The rest of this thesis is structured in the following way: In Chapter 2, I introduce Quantum computing, specifically Quantum Random Walks, in a bottom-up approach, starting from the simplest form and then generalizing it. Contrary to many authors, I use linear algebra exclusively to describe each step since implementation on a universal quantum computer requires the definition to come in the form of unitary transformations.

Section 2.2.5 discusses two of the generalization techniques found in~\cite{Portugal}. I present my improvement to one of these methods, which I have proven to have the equivalent result but remove an exponential memory requirement from the implementation. The other method in~\cite{Portugal} uses a constraint about the evolution operator, for which I have not found proof in the literature. Here, I present my more generalized version of this constraint and the proof I have given.

In Chapter 3, I introduce three bioinformatics problems: DNA sequencing, Protein folding and Molecular docking. I explain the computational models that emerge from these practical problems and the well-known computational problems they reduce to.

In Chapter 4, I describe my simulator software's architecture and implementation details and present the results obtained from my simulation runs.